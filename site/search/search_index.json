{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This course is for understanding C-programming (as a systems programming language), Embedded Systems, Computer Architecture, Operating Systems, and Computer Graphics, However, the main purpose of this course is to demystifying the ESP-IDF and the ESP32 system hardware from espressif.</p>"},{"location":"#who-is-this-course-for","title":"Who is this course for?","text":"<p>This course is for people who have a good understanding of embedded systems programming, C and C++ programming, as well as a little bit of knowledge on Computer Graphics.</p>"},{"location":"#what-is-this-course-and-why-am-i-making-it","title":"What is this course and why am I making it?","text":"<p>This course is supposed to cover everything relating to embedded systems and the ESP-IDF. So some important topics we will go over is C-programming, Operating Systems, Computer Architecture, and Computer Graphics. </p> <p>[!question] Why are we covering so much C? Well since I want to write everything using the C language and since this is also a learning experience for me I want to write every lesson in C and include examples from real world projects in my lessons.</p> <p>This is a course that will go through the research that I have done to make a course on embedded systems and esp32/esp-idf programming. This course will not use Adruino. </p> <p>[!NOTE] (Nothing against Adruino users hopefully this link will help get you to the right place.)</p> <p>I am making this course for 2 reasons: 1. There is not a lot of good resources for esp-idf other than the official documentation. 2. This will give me motivation to do research on these topics and help me understand them as well.</p>"},{"location":"#how-can-you-help","title":"How Can You Help","text":"<p>This course will of course be free :) I am trying to learn and hopefully you will learn with me. The only thing is that I ask for is engagement. Point out what I have wrong, helping me find the correct information, and give me feedback I really want to make this a helpful and reliable resource. I will allow for comment sections on my pages so that people can give feedback and corrections. When I feel comfortable with the information and completeness of this course I will create a video series that I will also make free.</p>"},{"location":"#comments-on-other-courses","title":"Comments On Other Courses","text":"<p>The only good course I have found on esp32 and the esp-idf is this course here. This course is great and it is a great way to get you started on embedded systems programming on the esp32 board. However, it is missing some information, espeically when it comes to rendering graphics on the LCD displays. It also does not contain the optimization features that were added to esp32-s3, which contain extra registers for specific operations. </p> <p>But again this course will also cover a lot of <code>C</code>, <code>C++</code>, <code>Computer Architecture</code>, <code>Operating Systems</code>, <code>Assembly Instructions</code>, <code>Embedded Systems</code>, and <code>Computer Graphics</code> So there will be a lot of information that here that I will cover that might have better sources. I will try to link all of my sources that I use and also identify the sources that I think are best for learning more on each topic.</p>"},{"location":"#brief-introduction","title":"Brief Introduction","text":"<p>I am a student who has a passion for the Software Engineering community and learning. I got my undergraduate in computer science from the University of Georgia, and I am currently working on my Masters at Georgia Tech. I have contributed to open source projects and have a passion for maintaining and using open source software whenever I can. I have worked with professional software for about 4 years. I am a bit of a noob when it comes to the professional enviroment but I love learning and hope that I can do and add value to the software engineering community. I also like playing league of legends, but I cant play anymore because of how addicted I get. Here are my op.ggs:</p> <p>main</p> <p>testing new champs</p> <p>being a degenerate</p>"},{"location":"#what-sets-this-course-apart-from-others","title":"What sets this course apart from others?","text":"<p>This course is a work in progress and will be kind of an open source course. It will try to go in-depth into how the esp-idf works. This course will also contain a lot of practice projects and will be focused on embedded systems programming. So all of the topics we cover like: <code>C</code>, <code>C++</code>, <code>Computer Architecture</code>, <code>Operating Systems</code>, <code>Assembly Instructions</code>,  and <code>Computer Graphics</code> will all be in the context of embedded systems. I will try to find examples in real world projects for each concept we cover that exsists within an embedded system.</p> <p>For example: Lets say we are learning about buffers in C, I will provide an example of how a buffer in C is used within an embedded system.</p> <p><pre><code>    ESP_LOGI(TAG, \"Initialize RGB LCD panel\");\n    ESP_ERROR_CHECK(esp_lcd_panel_reset(panel_handle));\n    ESP_ERROR_CHECK(esp_lcd_panel_init(panel_handle));\n\n    ESP_LOGI(TAG, \"Turn on LCD backlight\");\n    example_bsp_set_lcd_backlight(EXAMPLE_LCD_BK_LIGHT_ON_LEVEL);\n\n    ESP_LOGI(TAG, \"Initialize LVGL library\");\n    lv_init();\n    // create a lvgl display\n    lv_display_t *display = lv_display_create(EXAMPLE_LCD_H_RES, EXAMPLE_LCD_V_RES);\n    // associate the rgb panel handle to the display\n    lv_display_set_user_data(display, panel_handle);\n    // set color depth\n    lv_display_set_color_format(display, LV_COLOR_FORMAT_RGB565);\n    // create draw buffers\n    void *buf1 = NULL;\n    void *buf2 = NULL;\n#if CONFIG_EXAMPLE_DOUBLE_FB\n    ESP_LOGI(TAG, \"Use frame buffers as LVGL draw buffers\");\n    ESP_ERROR_CHECK(esp_lcd_rgb_panel_get_frame_buffer(panel_handle, 2, &amp;buf1, &amp;buf2));\n    // set LVGL draw buffers and direct mode\n    lv_display_set_buffers(display, buf1, buf2, EXAMPLE_LCD_H_RES * EXAMPLE_LCD_V_RES * sizeof(lv_color16_t), LV_DISPLAY_RENDER_MODE_DIRECT);\n</code></pre> example from https://github.com/espressif/esp-idf/blob/master/examples/peripherals/lcd/rgb_panel/main/rgb_lcd_example_main.c</p> <p>Then I would explain the individual pieces of this code the context and how and why a buffer was used.</p> <p>This course will also continually update with new technologies and I will always try and document the research that I do on these topics and how they relate to embedded systems programming.</p>"},{"location":"#what-you-will-need-for-this-course","title":"What you will need for this course","text":"<p>Its difficult to say what you will need, because it depends on how much of this course you intend to go through. But I will list what you need in order from most important to least important</p> <p>hardware requirements:</p> <ol> <li>Computer running: MacOS, Windows 10 | &gt;, Linux</li> <li>esp32 chip</li> <li>esp32s3 chip</li> <li>breadboard</li> <li>ttygo-display-t s3 or regular</li> </ol> <p>Somethings you might want to make sure you are comfortable with:</p> <ol> <li>C programming</li> <li>Python</li> <li>Embedded System Basics</li> <li>Networking Basics</li> <li>Operating System Basics</li> <li>GPU and CPU architecture</li> <li>Some familiarity with Assembly</li> </ol> <p>WE WILL NOT USE ADRUINO.</p> <p>ADRUINO HAS CLUTERRED THE WOLRD WITH ITS ADRUINONESS EVERY SEARCH FOR THESE TOPICS BRINGS UP ADRUINO STUFF</p>"},{"location":"#what-will-this-course-cover","title":"What will this course cover:","text":""},{"location":"#1-the-basics","title":"1. The Basics","text":""},{"location":"#11-computer-architecture","title":"1.1 Computer Architecture","text":"<ul> <li>ISA</li> <li>Microarchitecture</li> <li>System Design</li> <li>Assembly</li> <li>Logic Implementation</li> <li>Circuit Implementation</li> <li>Efficiency</li> <li>Processors</li> <li>Graphical Processing Units</li> </ul>"},{"location":"#12-c-programming","title":"1.2 C-Programming","text":"<ul> <li>Basic Syntax Quick</li> <li>Arrays:</li> <li>Arrays as Functions</li> <li>Character Arrays</li> <li>Memory:</li> <li>Heap vs Stack</li> <li>Dynamic Memory Allocation</li> <li>Everything Pointers</li> <li>Structures:</li> <li>Self-Referential Structures</li> <li>Unions</li> <li>Bit-Fields in Structures</li> <li>File Handling</li> <li>Advanced Memory Management and Pointers:</li> <li>Memory Leaks</li> <li>Memory Management Techniques</li> <li>Buffer Overflow</li> <li>Security Vulnerabilities</li> <li>Constant Pointers</li> <li>Void Pointers</li> <li>Function Pointer Arrays and Callbacks</li> <li>Preprocessor Directives:</li> <li>Macros</li> <li>Conditional Compilation</li> <li>File Inclusion</li> <li>Stringizing and Token Pasting</li> <li>Error Handling:</li> <li>Error Codes</li> <li>Assert Macros</li> <li>Setjmp and Longjmp for Non-Local Jumps</li> <li>Multithreading and Concurrency</li> <li>Data Structures (Quick)</li> <li>OOP Concepts in C</li> <li>Procedural Programming in C</li> <li>Networking:</li> <li>Sockets</li> <li>Client-Server</li> <li>TCP vs UDP</li> <li>Multithreaded Network App</li> <li>Protocols</li> <li>Low-Level Programming:</li> <li>Bitwise</li> <li>Inline Assembly</li> <li>Memory-Mapped I/O</li> <li>Interfacing with Hardware</li> <li>Embedded Systems</li> <li>C Advanced Memory for Embedded Systems:</li> <li>Custom Allocators</li> <li>Memory Pools</li> <li>Memory Alignment for SIMD and Specific Hardware</li> <li>Memory Fragments and Defrags</li> <li>Garbage Collection</li> <li>C Advanced Multithreading for Embedded Systems:</li> <li>Lock-Free Programming</li> <li>Thread Pools</li> <li>Atomic Operations</li> <li>Memory Barriers and Fences</li> <li>Deadlock Detection and Avoidance</li> <li>Concurrent Data Structures</li> <li>Compilers and Linkers:</li> <li>Writing C Compilers and Interpreters</li> <li>Compiler Optimization</li> <li>Linker Scripts</li> <li>Cross Compilation for Different Architectures</li> <li>Code Generation and Assembly Output from C</li> <li>IR Compiler Design</li> <li>Embedded C:</li> <li>Direct Register Access</li> <li>Writing Device Drivers</li> <li>ISR in Embedded Systems</li> <li>Bare Metal Programming</li> <li>Real-Time Operating System</li> <li>Low-Power Design and Energy-Aware Programming</li> <li>Metaprogramming:</li> <li>Metaprogramming with Injection</li> <li>Using Templates</li> <li>Code Abstraction</li> <li>Dynamic Libraries and Linkers:</li> <li>Creating and Using Shared Objects</li> <li>Position-Independent Code</li> <li>Inter-Process Communication</li> <li>Advanced File System and I/O:</li> <li>Async I/O (AIO, epoll, kqueue)</li> <li>Memory Mapped Files</li> <li>High Performance I/O Techniques (DMA, Zero-Copy I/O)</li> <li>Low-Level Debugging:</li> <li>Valgrind, Perf, Gprof</li> <li>Performance Counters</li> <li>Compiler Optimization Impact</li> <li>Reverse Engineering of Compiled C Code</li> <li>Stack Unwinding and Core Dump Analysis</li> <li>Systems Programming:</li> <li>System Calls</li> <li>Daemons</li> <li>Signals and Signal Handling</li> <li>Process Control IPC</li> <li>Memory Protection and Virtual Memory Management</li> <li>Writing Loadable Kernel Modules</li> <li>Hardware-Specific:</li> <li>Writing Bootloaders in C</li> <li>Firmware Development</li> <li>AVR, ARM Cortex Microcontroller Programming</li> <li>Optimization:</li> <li>Algorithmic Optimization and Profiling</li> <li>Manual Loop Optimization</li> <li>Cache-Friendly Code</li> <li>SIMD</li> <li>Processor-Specific Optimization</li> <li>Inline Assembly</li> </ul>"},{"location":"#2-embedded-systems","title":"2. Embedded Systems","text":""},{"location":"#21-intro","title":"2.1 Intro","text":"<ul> <li>Microcontroller vs Microprocessor</li> <li>Von Neumann Architecture</li> <li>IoT, Consumer Electronics, Automotive Devices</li> <li>Software vs Firmware</li> </ul>"},{"location":"#22-system-design","title":"2.2 System Design","text":"<ul> <li>Partitioning</li> <li>Environments</li> <li>Functional Prototyping and Simulations</li> </ul>"},{"location":"#23-architecture","title":"2.3 Architecture","text":"<ul> <li>CPU Core (RISC, CISC, ARM Cortex, etc.)</li> <li>System Buses (AMBA, AHB, APB)</li> <li>Registers, Program Counter, Stack Pointer</li> <li>Memory Maps (Code, Data, Stack, Heap)</li> <li>Memory Types (ROM, RAM, Flash, EEPROM)</li> <li>I/O Ports (GPIO, Analog vs Digital)</li> </ul>"},{"location":"#24-programming-embedded-systems","title":"2.4 Programming Embedded Systems","text":"<ul> <li>Writing Bare Metal Code (No OS)</li> <li>Writing and Debugging Firmware</li> <li>Startup Code and Initialization Sequences</li> <li>Reset and Boot Sequences</li> <li>Handling Interrupts and ISRs (Interrupt Service Routines)</li> <li>Peripheral Control Registers (Memory-Mapped I/O)</li> </ul>"},{"location":"#25-rtos","title":"2.5 RTOS","text":"<ul> <li>This will need its own course</li> </ul>"},{"location":"#26-power-management","title":"2.6 Power Management","text":"<ul> <li>Power Consumption in Embedded Systems</li> <li>Sleep Modes and Low-Power States</li> <li>Dynamic Power Scaling</li> <li>Dynamic Voltage Frequency Scaling</li> <li>Power Gating and Clock Gating</li> <li>Energy Efficient Hardware and Software</li> </ul>"},{"location":"#27-interrupts-and-exception-handling","title":"2.7 Interrupts and Exception Handling","text":"<ul> <li>Interrupt Vector Table</li> <li>Nested Vectored Interrupt Controller</li> <li>Prioritizing Interrupts</li> <li>Software Interrupts and Traps</li> <li>Synchronous vs Asynchronous Interrupts</li> </ul>"},{"location":"#28-memory-management","title":"2.8 Memory Management","text":"<ul> <li>Static vs Dynamic Allocation</li> <li>MPU (Memory Protection Unit)</li> <li>DMA (Direct Memory Access)</li> <li>Cache Control</li> <li>Memory Access Latency Optimization</li> <li>Non-Volatile Memory Programming</li> </ul>"},{"location":"#29-peripherals-and-communication-protocols","title":"2.9 Peripherals and Communication Protocols","text":"<ul> <li>Universal Asynchronous Receiver/Transmitter (UART)</li> <li>Serial Peripheral Interface (SPI)</li> <li>Inter-Integrated Circuit (I2C)</li> </ul>"},{"location":"#210-timers","title":"2.10 Timers","text":""},{"location":"#211-bootloaders","title":"2.11 Bootloaders","text":"<ul> <li>Understanding Bootloaders</li> <li>Customizing Bootloaders</li> <li>Booting from Flash, EEPROM, and SD Cards</li> <li>Secure Bootloaders and Cryptographic Signing</li> <li>Chain Bootloaders</li> </ul>"},{"location":"#3-operating-systems","title":"3. Operating Systems","text":""},{"location":"#31-processes-and-threads","title":"3.1 Processes and Threads","text":"<ul> <li>Process Lifecycle</li> <li>Process Control Block</li> <li>Threads</li> <li>User-Level vs Kernel-Level Threads</li> <li>Thread Scheduling and Context Switching</li> </ul>"},{"location":"#32-process-synchronization","title":"3.2 Process Synchronization","text":"<ul> <li>Race Conditions</li> <li>Critical Section Problem</li> <li>Mutexes and Semaphores</li> <li>Monitors and Condition Variables</li> <li>Deadlocks</li> <li>Inter-Process Communication</li> </ul>"},{"location":"#33-cpu-scheduling","title":"3.3 CPU Scheduling","text":"<ul> <li>Scheduling Algorithms</li> <li>Preemptive vs Non-Preemptive Scheduling</li> <li>Multi-Level Queue Scheduling</li> <li>Multi-Processor Scheduling</li> <li>Real-Time Scheduling</li> </ul>"},{"location":"#34-memory-management","title":"3.4 Memory Management","text":"<ul> <li>Memory Hierarchy (Registers, Cache, Main Memory, Secondary Storage)</li> <li>Paging and Segmentation</li> <li>Virtual RAM</li> <li>Page Replacement Algorithms</li> <li>Memory Allocation Techniques</li> <li>Demand Paging and Swapping</li> </ul>"},{"location":"#35-file-systems","title":"3.5 File Systems","text":""},{"location":"#36-io-systems","title":"3.6 I/O Systems","text":"<ul> <li>Controllers, Ports, Buses</li> <li>Polling vs Interrupt-Driven I/O</li> <li>DMA</li> <li>I/O Scheduling</li> <li>Disk Scheduling</li> <li>RAID Levels</li> </ul>"},{"location":"#37-security","title":"3.7 Security","text":"<ul> <li>System Security</li> <li>Protection Mechanisms</li> <li>Secure Operating Systems</li> <li>Attack Vectors</li> <li>Malware and Intrusion Detection</li> <li>Secure Boot and Trusted Computing</li> </ul>"},{"location":"#38-kernel-programming","title":"3.8 Kernel Programming","text":"<ul> <li>Kernel Mode vs User Mode</li> <li>System Calls</li> <li>Kernel Data Structures</li> <li>Writing Kernel-Level Modules and Drivers</li> <li>Kernel Preemption and Real-Time Kernels</li> <li>Scheduling in Kernel Space</li> </ul>"},{"location":"#39-distributed-systems","title":"3.9 Distributed Systems","text":"<ul> <li>Characteristics of Distributed Systems</li> <li>Distributed File Systems</li> <li>Distributed Coordination</li> <li>Time and Clock Sync</li> <li>Distributed Process Scheduling</li> <li>CAP Theorem</li> </ul>"},{"location":"#4-assembly-and-basic-computer-organization","title":"4. Assembly and Basic Computer Organization","text":""},{"location":"#41-assembly","title":"4.1 Assembly","text":"<ul> <li>What is Assembly</li> <li>Why Use Assembly</li> <li>Machine Language vs Assembly</li> <li>Assembly Syntax</li> <li>Assembler, Linker, Loader</li> </ul>"},{"location":"#42-logic-gates-and-boolean-algebra","title":"4.2 Logic Gates and Boolean Algebra","text":"<ul> <li>Logic Gates (AND, OR, NOT, XOR, NAND, NOR)</li> <li>Truth Tables and Boolean Expressions</li> <li>Combinational Logic Circuits</li> <li>K-Maps</li> <li>Hardware Implementation</li> </ul>"},{"location":"#43-alu-arithmetic-logic-unit","title":"4.3 ALU (Arithmetic Logic Unit)","text":"<ul> <li>Role of the ALU in the CPU</li> <li>Arithmetic Operations</li> <li>Bitwise Operations</li> <li>Signed and Unsigned Arithmetic</li> <li>Overflow and Underflow Detection in ALU</li> <li>Building an ALU with Logic Gates</li> </ul>"},{"location":"#44-registers-and-data-movement","title":"4.4 Registers and Data Movement","text":"<ul> <li>Role of Register in the CPU</li> <li>General Purpose vs Special Purpose Registers</li> <li>Register Operations</li> <li>Stack Pointer and Frame Pointer Registers</li> <li>Register Indirect Addressing</li> <li>Shift Registers and Their Use in Data Manipulation</li> </ul>"},{"location":"#45-control-unit","title":"4.5 Control Unit","text":"<ul> <li>Role of the Control Unit in Instruction Execution</li> <li>Microprogrammed vs Hardwired Control Units</li> <li>Control Signals and Timing Diagrams</li> <li>Fetch-Decode-Execute Cycle</li> <li>Control Unit Logic Gates</li> </ul>"},{"location":"#46-instruction-set-architecture","title":"4.6 Instruction Set Architecture","text":"<ul> <li>Understanding ISA Layer</li> <li>CISC vs RISC Architecture</li> <li>Instruction Formats (OPCODE, Operands, Addressing Modes)</li> <li>Addressing Modes</li> <li>Instruction Pipelining</li> <li>Performance Implication of Different ISAs</li> </ul>"},{"location":"#47-x86","title":"4.7 x86","text":"<ul> <li>x86 Registers</li> <li>x86 Instruction Set</li> <li>x86 Addressing Modes</li> <li>Stack Operations</li> <li>Floating Point Arithmetic</li> </ul>"},{"location":"#48-risc","title":"4.8 RISC","text":"<ul> <li>Overview of RISC</li> <li>RISC Registers and Register Windows</li> <li>RISC Instruction Pipelining</li> <li>Load/Store Architecture</li> <li>Modern RISC Architectures (ARM, MIPS, RISC-V)</li> </ul>"},{"location":"#49-assembler-and-linker","title":"4.9 Assembler and Linker","text":""},{"location":"#410-microprogramming","title":"4.10 Microprogramming","text":""},{"location":"#411-floating-point-arithmetic","title":"4.11 Floating Point Arithmetic","text":""},{"location":"#412-branching-and-control-flow","title":"4.12 Branching and Control Flow","text":"<ul> <li>Conditional and Unconditional Branching</li> <li>Loops and Jumps</li> <li>Comparing and Testing</li> <li>Call and Return</li> <li>Subroutines and Procedure Calls</li> <li>Stack Frame Management and Recursive Calls</li> </ul>"},{"location":"#413-low-level-hardware-interfacing","title":"4.13 Low-Level Hardware Interfacing","text":"<ul> <li>Assembly with Hardware</li> <li>ISR (Interrupt Service Routine)</li> <li>Writing Device Drivers in Assembly</li> <li>Direct Memory Access (DMA)</li> <li>I/O Control</li> </ul>"},{"location":"#414-advanced-control-unit-design","title":"4.14 Advanced Control Unit Design","text":"<ul> <li>Finite State Machine</li> <li>Timing and Control Clocking</li> <li>Generating Control Signals from Microinstructions</li> <li>Power Efficient Control Unit Design</li> </ul>"},{"location":"#415-optimizing-assembly-code","title":"4.15 Optimizing Assembly Code","text":"<ul> <li>Loop Unrolling</li> <li>Instruction Scheduling and Reordering</li> <li>Reducing Branching Penalties</li> <li>Minimizing Memory Accesses</li> <li>SIMD</li> </ul>"},{"location":"#416-emerging-architectures-and-trends","title":"4.16 Emerging Architectures and Trends","text":"<ul> <li>RISC-V</li> <li>Quantum Assembly</li> <li>ARM64</li> <li>VLIW</li> <li>FPGAs</li> <li>Assembly for Embedded Systems</li> </ul>"},{"location":"#5-computer-graphics-and-linear-algebra","title":"5. Computer Graphics and Linear Algebra","text":""},{"location":"#51-computer-graphics-intro","title":"5.1 Computer Graphics Intro","text":"<ul> <li>What is Computer Graphics</li> <li>2D vs 3D Graphics</li> <li>Graphics Libraries in C (OpenGL, Vulkan, DirectX)</li> <li>Coordinate System and Screen Space</li> <li>Pixels and Framebuffers</li> </ul>"},{"location":"#52-raster-graphics","title":"5.2 Raster Graphics","text":"<ul> <li>Drawing Points and Lines (Bresenham's Line Algorithm)</li> <li>Line Clipping</li> <li>Circle and Ellipse Drawing Algorithms</li> <li>Polygon Filling Algorithms</li> <li>Antialiasing Techniques</li> <li>Bitmap Manipulation</li> </ul>"},{"location":"#53-3d-graphics-pipelines","title":"5.3 3D Graphics Pipelines","text":"<ul> <li>Transformations</li> <li>Homogeneous Coordinates and Perspective Division</li> <li>Viewport Transformations</li> <li>Backface Culling and Depth Buffering</li> <li>Shaders and Programmable Pipeline</li> </ul>"},{"location":"#54-basic-3d-geometry","title":"5.4 Basic 3D Geometry","text":"<ul> <li>Points, Vectors, and Normals</li> <li>Vector Operations</li> <li>Planes and Lines in 3D</li> <li>Bounding Volumes</li> <li>Ray Casting and Ray-Sphere, Ray-Plane Intersections</li> <li>Spatial Data Structures</li> </ul>"},{"location":"#55-transformations","title":"5.5 Transformations","text":"<ul> <li>Translation, Rotation, and Scaling</li> <li>Rotation Matrices and Quaternions</li> <li>Matrix Transformations</li> <li>Composite Transformations</li> <li>Coordinate Spaces</li> <li>Camera Models</li> </ul>"},{"location":"#56-shading-and-lighting","title":"5.6 Shading and Lighting","text":"<ul> <li>The Phong Reflection Model</li> <li>Gouraud Shading vs Phong Shading</li> <li>Directional, Point, and Spot Lights</li> <li>Attenuation</li> </ul>"},{"location":"#57-texturing","title":"5.7 Texturing","text":""},{"location":"#58-graphics-optimization","title":"5.8 Graphics Optimization","text":"<ul> <li>Level of Detail Techniques</li> <li>Frustum Culling and Occlusion Culling</li> <li>Optimizing the Pipeline</li> <li>Memory Management</li> <li>GPU vs CPU</li> </ul>"},{"location":"#59-vectors","title":"5.9 Vectors","text":""},{"location":"#510-matrices","title":"5.10 Matrices","text":""},{"location":"#511-transformations","title":"5.11 Transformations","text":""},{"location":"#512-functions-of-several-variables","title":"5.12 Functions of Several Variables","text":""},{"location":"#513-gradients-and-optimization","title":"5.13 Gradients and Optimization","text":""},{"location":"#514-multiple-integrals","title":"5.14 Multiple Integrals","text":""},{"location":"#515-vector-calculus","title":"5.15 Vector Calculus","text":""},{"location":"#516-curves-and-surfaces-in-3d","title":"5.16 Curves and Surfaces in 3D","text":""},{"location":"#6-the-esp-idf","title":"6. The ESP-IDF","text":""},{"location":"#61-introduction","title":"6.1 Introduction","text":"<ul> <li>Setting Up Environment</li> <li>ESP-IDF Project Structure</li> </ul>"},{"location":"#62-esp32-system-architecture","title":"6.2 ESP32 System Architecture","text":"<ul> <li>Dual-Core Architecture</li> <li>Memory and Memory Map</li> <li>Power Management and Sleep Modes</li> <li>Clocking Systems and Clock Tree</li> <li>ROM Bootloader, Application Loading, and Execution</li> <li>App Partitioning and Bootloader Configuration</li> </ul>"},{"location":"#63-freertos-and-multitasking","title":"6.3 FreeRTOS and Multitasking","text":"<ul> <li>Understanding FreeRTOS Kernel in ESP32</li> <li>Task Creation, Scheduling, and Priorities</li> <li>Synchronization (Semaphores, Queues, and Mutexes)</li> <li>Task and CPU Management:</li> <li>Switching Between Cores</li> <li>Memory Management</li> <li>Performance Monitoring</li> <li>Task Notifications</li> <li>Event Groups</li> <li>Timers</li> <li>Callbacks</li> <li>High-Resolution Timers</li> <li>IPC (Inter-Process Communication)</li> <li>FreeRTOS Tickless Idle</li> <li>FreeRTOS Trace and Statistics</li> <li>Task State Monitoring</li> <li>Performance Profiling</li> </ul>"},{"location":"#64-gpio-and-peripherals","title":"6.4 GPIO and Peripherals","text":"<ul> <li>Configure GPIO</li> <li>GPIO Pull-up/Pull-down Resistors</li> <li>Using GPIO Interrupts for Real-Time Events</li> <li>Using SPI Interface</li> <li>I2C Communication</li> <li>PWM and LED Control</li> </ul>"},{"location":"#65-adc-and-dac","title":"6.5 ADC and DAC","text":"<ul> <li>Analog to Digital Conversion (ADC)</li> <li>Digital to Analog Conversion (DAC)</li> </ul>"},{"location":"#66-serial-communication","title":"6.6 Serial Communication","text":"<ul> <li>UART</li> <li>SPI</li> <li>I2C</li> </ul>"},{"location":"#67-networking-with-esp32","title":"6.7 Networking with ESP32","text":"<ul> <li>Wi-Fi</li> <li>TCP/IP</li> <li>UDP</li> <li>HTTP/HTTPS</li> </ul>"},{"location":"#68-bluetooth","title":"6.8 Bluetooth","text":""},{"location":"#69-http-https-and-web-services","title":"6.9 HTTP, HTTPS, and Web Services","text":""},{"location":"#610-security-and-encryption","title":"6.10 Security and Encryption","text":""},{"location":"#611-file-systems","title":"6.11 File Systems","text":"<ul> <li>NVS (Non-Volatile Storage)</li> <li>SPIFFS and FAT</li> </ul>"},{"location":"#612-ota-over-the-air-updates","title":"6.12 OTA (Over-The-Air) Updates","text":""},{"location":"#613-advanced-freertos-and-task-management","title":"6.13 Advanced FreeRTOS and Task Management","text":"<ul> <li>Using Message Queues, Semaphores, and Event Groups</li> <li>Advanced Task Synchronization</li> <li>Memory Allocation</li> <li>Inter-Process Communication</li> </ul>"},{"location":"#614-power-management","title":"6.14 Power Management","text":""},{"location":"#615-system-timers","title":"6.15 System Timers","text":""},{"location":"#616-performance-monitoring","title":"6.16 Performance Monitoring","text":""},{"location":"#617-esp-idf-logging","title":"6.17 ESP-IDF Logging","text":""},{"location":"#618-heap-debugging","title":"6.18 Heap Debugging","text":""},{"location":"#619-performance-optimization-techniques","title":"6.19 Performance Optimization Techniques","text":""},{"location":"#620-motor-control","title":"6.20 Motor Control","text":""},{"location":"#621-touch-and-temperature-sensor","title":"6.21 Touch and Temperature Sensor","text":""},{"location":"#622-advanced-gpio-and-interrupts","title":"6.22 Advanced GPIO and Interrupts","text":""},{"location":"#7-esp-idf-game-development","title":"7. ESP-IDF Game Development","text":""},{"location":"#71-introduction","title":"7.1 Introduction","text":""},{"location":"#72-esp-basic-game-loop-with-freertos","title":"7.2 ESP Basic Game Loop with FreeRTOS","text":""},{"location":"#73-display-and-graphics-programming","title":"7.3 Display and Graphics Programming","text":"<ul> <li>Displays</li> <li>Drawing Basic Shapes and Images</li> <li>Sprite Handling and Animation</li> </ul>"},{"location":"#74-user-input-and-interaction","title":"7.4 User Input and Interaction","text":"<ul> <li>Handling Buttons</li> <li>Touch Integration</li> <li>Input Debouncing and Response Optimization</li> </ul>"},{"location":"#75-game-physics","title":"7.5 Game Physics","text":"<ul> <li>Collisions</li> <li>Game State Management</li> </ul>"},{"location":"#76-sound-integration","title":"7.6 Sound Integration","text":"<ul> <li>I2S for Audio Output</li> <li>Creating and Playing Sound Effects</li> <li>Controlling Volume and Audio Quality</li> </ul>"},{"location":"#77-networking-and-multiplayer","title":"7.7 Networking and Multiplayer","text":"<ul> <li>Introduction to Networking in Games</li> <li>Client-Server</li> <li>Websockets</li> </ul>"},{"location":"#78-graphics-optimization","title":"7.8 Graphics Optimization","text":"<ul> <li>Game Loop for Real-Time Performance</li> <li>Power Resource Management</li> </ul>"},{"location":"#79-game-menus","title":"7.9 Game Menus","text":""},{"location":"#710-nvs-for-saving-game-states","title":"7.10 NVS for Saving Game States","text":""},{"location":"#8-esp32-idf-cryptocurrency","title":"8. ESP32-IDF Cryptocurrency","text":"<p>TBD</p>"},{"location":"Course/C-programming/arrays/arrays/","title":"Arrays in C and Differences Between C Versions","text":""},{"location":"Course/C-programming/arrays/arrays/#memory-as-a-storage-unit","title":"Memory as a Storage Unit","text":"<p>In C, arrays are simply a series of memory blocks that are allocated for a program to fill with different types of data. Imagine the stack or the heap as a storage unit, where invisible lines divide the storage unit into equal parts for data storage.</p> <p>Before you place your data into this \"storage unit,\" it consists of various remnants\u2014like oxygen, nitrogen, hydrogen, water vapor, maybe some dust, and likely leftover junk from the storage unit\u2019s previous user.</p>"},{"location":"Course/C-programming/arrays/arrays/#partitioning-the-storage-unit","title":"Partitioning the Storage Unit","text":"<p>You can draw invisible lines that separate the room and allow you to place whatever you want in those spaces. However, before you put anything into those spaces, you'll want to clear out the junk that's already there. In C, this cleanup step is usually handled when you place elements into your array, but let\u2019s pretend you only put one item into the first partition and leave the rest.</p> <p>When you define an array, you create space in memory to perfectly fit your objects. For simplicity\u2019s sake, let\u2019s say you draw five equally spaced imaginary partitions that perfectly fit the objects you want to store\u2014in this case, let\u2019s imagine blocks of iron.</p> <pre><code>// Defining an array in C\nint ironBlocks[5]; // Creates an array with 5 partitions\n</code></pre>"},{"location":"Course/C-programming/arrays/arrays/#what-happens-if-you-dont-clear-out-the-data-in-your-array","title":"What Happens if You Don't Clear Out the Data in Your Array?","text":"<p>Let\u2019s say you only put one iron block in one of the partitions. Technically, you have space for five blocks of iron, but you\u2019ve only used one space. The remaining four partitions still contain leftover junk from the previous \"user\" of this storage unit. So, when you print out your array, you may see random garbage values in those uninitialized spaces.</p> <p>Here\u2019s what that might look like in C:</p> <p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int ironBlocks[5];  // Uninitialized array\n    ironBlocks[0] = 1;  // Only first space is initialized\n\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"%d\\n\", ironBlocks[i]);  // Uninitialized elements may print garbage values\n    }\n    return 0;\n}\n</code></pre> Output (Example):</p> <pre><code>1\n6422296  // Random value\n6422228  // Random value\n0        // Random value\n-12177636 // Random value\n</code></pre> <p>This is because the array only clears the first block (where you placed your iron block), while the remaining spaces contain \"junk data\" that was left behind by the system or other programs.</p> <p>![[Pasted image 20240917073020.png]]</p>"},{"location":"Course/C-programming/arrays/arrays/#buffer-overflows","title":"Buffer Overflows","text":"<p>![[Screenshot 2024-09-17 at 7.35.05 AM.png]]</p> <p>Now, let\u2019s discuss buffer overflows. Imagine you\u2019ve partitioned space in your storage unit for five blocks of iron. After filling all five spaces, you decide to add a sixth block. This new block sticks out of the predefined space.</p> <p>Why is this a problem?</p> <ul> <li>Data Exposure: The iron block now sticks out of the storage unit, allowing other users (programs) to see or access it. If the data you\u2019re storing is sensitive, this could expose it to potential theft or misuse.</li> <li>Overwriting Memory: The sixth block could overwrite important information stored elsewhere. For example, what if the sixth block crushes a partition meant for your foam blocks? You\u2019ll end up with a block of iron where there should have been foam.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int ironBlocks[5];\n    for (int i = 0; i &lt;= 5; i++) {\n        ironBlocks[i] = i + 1;  // Causes buffer overflow when i = 5\n    }\n    return 0;\n}\n</code></pre> <p>Buffer Overflow: In this code, the loop accesses <code>ironBlocks[5]</code>, which is outside the allocated array size (0 to 4), causing a buffer overflow. This could lead to unintended behavior, memory corruption, or even security vulnerabilities.</p>"},{"location":"Course/C-programming/arrays/arrays/#code-example-avoiding-junk-data-with-initialization","title":"Code Example: Avoiding Junk Data with Initialization","text":"<p>One way to avoid junk data in your arrays is by initializing them:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int ironBlocks[5] = {0};  // All elements are initialized to 0\n\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"%d\\n\", ironBlocks[i]);\n    }\n\n    return 0;\n}\n</code></pre> <p>Output:</p> <p><code>0 0 0 0 0</code></p> <p>In this case, all the partitions are cleared, and the array is initialized with <code>0</code> in each space.</p> <p>With these code examples and visual illustrations (storage units with imaginary partitions), you should now have a better understanding of how arrays work in C, how junk data remains if not initialized, and how buffer overflows can lead to serious problems.</p>"},{"location":"Course/C-programming/basic_syntax_quick/basic_syntax_quick/","title":"Introduction to C and Basic Syntax","text":""},{"location":"Course/C-programming/basic_syntax_quick/basic_syntax_quick/#history-of-c","title":"History of C","text":"<p>The C programming language was developed in the 1970s and during this time there was not a consensus on what high level language was going to be best for writing operating systems. Most operating systems were written in the Assembly language. The Assembly language is a set of instructions you write that will compile into machine code instructions for the cpu. So each time you write a line of Assembly that will represent machine code. To give you some context the windows operating system has 50 million lines of code. The windows operating system is not written in Assembly, there are probably some files that are written in Assembly but it is written mainly in the C language. If you had to write the windows operating system completely in Assembly it would probably end up being like 5 billion lines of code.</p> <p>So the programmers in the 70s knew that they wanted to create a language that could effectively write operating systems and allow them to write it within the age of one persons life. There were some predecessors to C. There was fortran and B. B is was an attempt to write what C would eventually become. In 1972 the new B was released by the GOAT Dennis Ritchie and eventually named it C. The missing ingredient of C was a compiler which basically takes code and turns it into a binary that the computer can execute. ![[Pasted image 20240915105701.png]] And the C programming language was born!</p>"},{"location":"Course/C-programming/basic_syntax_quick/basic_syntax_quick/#why-you-should-use-c","title":"Why you should use C","text":"<p>When I was in college I took many programming classes, Introduction to Computer Science, Theory of Computing, Introduction to Software Development, Web Development, Software Engineering, I even took Systems Engineering which had us program in C. However, there is this feeling that you get and I am sure that others have felt this as well. \"How does this even work\" what I mean to say is. How does this </p> <p><pre><code>for(int i = 0; i &lt; 10; i ++){\nprintf(\"this \\\\n\")\n}\n</code></pre> turn into this</p> <pre><code>this\nthis\nthis\nthis\nthis\nthis\nthis\nthis\nthis\nthis\n</code></pre> <p>and further more how the fuck does the command \"npm install\" work. There is so much prerequisite knowledge you are missing to understand how these commercial development tools actually work. And it is way easier to understand these things if you learn how to build them from the ground up. </p> <p>Now you might say, \"I only have so much time in my life, I am never going to build an operating system or a usb driver, I am not going to make money learning all the capablities of the C language\", That is a good point. If you want to get a job in tech, you can just take a Angular.js course that will take about 6 months and you will know everything you need to know to make 70k a year building beautiful websites. If you are just looking to make money from software this course is not for you. If you are worried that Chatgpt-4o1 could take your job. This course is not for you. This course is for people who are passionate about programming. People who program for the sake of programming and want to contribute to the overall software engineering knowledge base. I am not getting my masters and phd because I want to make more money. I am doing it because I love programming. This course is an open source project and I hope others will help me contribute to an amazing knowledge base.</p> <p>So why should you learn C. You should learn C because it is the language that wrote the language that was used to build your development tools. It is the language that wrote your operating system. It is the language that you need to know to talk to hardware. It is the language that wrote the most popular language in the world right now, Python. So for people who don't care about efficiency and time, and people who are a lot more about understanding and improving as developers, C is the best language. We will dip into other languages like C++ and Python occasionally since there are some great tools used in Python. However, we wont use any tools unless we 100% know how they work first. So that is why we will use C.</p>"},{"location":"Course/C-programming/basic_syntax_quick/basic_syntax_quick/#c-programming-syntax-and-fundamentals","title":"C programming syntax and fundamentals","text":"<p>The C language uses 4 basic primitive types: <code>char</code>, <code>int</code>,<code>float</code>, and <code>double</code>.</p> <p>C has added a lot more complex types since its release but the only other important type you should know about is the Boolean type which can be added through the  header. and use as <code>bool</code>. <p>Lets break down some C syntax real quick</p> <pre><code>#include &lt;stdio.h&gt;  \n\nint\u00a0main() {  \n\u00a0 printf(\"Hello World!\");  \n\u00a0\u00a0return\u00a00;  \n}\n</code></pre> <p>The top line #include  is the header file that it is including stdio.h is a standard library for C and contains most of the common input/output functionality in C. <p>The main function has a return type of int and takes no parameters. Inside the function there is a print statement. The C language uses <code>printf</code> in order to print to standard output.</p> <p>The main function returns 0. if you read the C documentation you will see that every main function has a return value which represents that type of exit that was produced.</p> <p>Hopefully this is all review the next chapters will go into more advanced concepts in the C language.</p> <p>&amp;Sources 1. https://www.youtube.com/watch?v=de2Hsvxaf8M&amp;ab_channel=Computerphile 2. https://softkeys.uk/blogs/blog/how-many-lines-of-code-in-windows-10 3. https://en.wikipedia.org/wiki/C_(programming_language) 4. https://www.linkedin.com/pulse/why-you-should-learn-c-your-first-language-saroj-kumar-sharma/</p>"}]}